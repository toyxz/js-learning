## 计算机基础

>介绍一下对于 http 的理解？
* http 是 client和server 沟通 时需要遵循的 规范，一种通信的协议
    * 在OSI参考模型中 是基于 TCP/IP 协议的应用层协议，默认使用80端口。
* http的通信过程
* http的特点
    http是一种无状态无连接的协议，所谓的无状态是每一次http链接都没办法记住当前的状态/身份信息等。由于这种缺点，引入cookie和session来保存状态信息。
* http的数据包结构
    分为 请求行 请求头 空行 请求体
    * 请求行 包括 ：请求方法 请求的url http协议
    * 请求头 ：User-Agent（产生请求的浏览器类型）、Accept：客户端可识别的内容类型列表 等
    * 空行： 发送回车符和换行符，通知服务器以下不再有请求头
    * 请求数据/体： 一般是post方法发送的参数的数据
* http状态码
    * 200 OK：客户端请求成功。
    * 301：永久性重定向
    * 302：临时重定向
    * 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
    * 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
    * 403 Forbidden：服务器收到请求，但是拒绝提供服务。
    * 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
    * 500 Internal Server Error：服务器发生不可预期的错误。
    * 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。
* http需要先进行TCP三次握手
    * http协议只定义了应用层的东西，下层的可靠性要传输层来保证，但是没有说一定要用tcp，只要是可以保证可靠性传输层协议都可以承载http
    * 关于TCP握手
* http1.0、 1.1 、2 、3 的区别
    * http 1.0 主要有三个命令 GET POST HEAD，在http/1.0时代，每一个请求都会重新建立一个tcp链接，一旦响应返回，就关闭连接。
    * http1.1新增了```keep-alive```功能，当浏览器建立一个TCP连接时，多个请求都会使用这条连接。（现在大多数浏览器默认都是开启的）,这样可以减少TCP握手的时间消耗。在一个TCP连接中，同一时间只能发送一个请求，并且需要等响应完成后才发送第二个请求。因此```HTTP/1.1制定了pipeLining管道```。通过这个管道，浏览器的多个请求可以同时发到服务器，但是服务器的响应只能够一个接着一个的返回（但有些浏览器不支持）
        * 同一域名最多只能建立六个连接，我们可以使用```子域名来减少所有资源在只有一个连接时的产生的排队延迟``
        * http1.1还支持```断点续传```，HTTP状态码应该是206。客户端在HTTP头中增加：Range，服务端收到断点续传请求后添加状态头Content-Range。断点续传遇到文件修改，If-Modified-Since/ETag头
    * 针对前面提到的1.0 1.1的特性，http2.0提出一些新的特性或者说是方法。（2015年正式发表）
        * ```二进制分帧```
            * 在应用层与传输层之间增加一个二进制分帧层。在二进制分帧层上，HTTP2.0会将所有传输的消息分割成更小的消息和帧。
        * ```压缩头部```
            * HTTP2.0规定了在客户端和服务端会使用并且维护【首部表】来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次。
事实上，如果请求中不包含首部（例如对同一资源的轮询请求）那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。
如果首部发生了变化，那么只需要发送变化了数据再Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表再HTTP2.0的连接存续期内始终存在，由客户端和服务器共同渐进地更新。
        * ```多路复用```
            * 在一条连接上，我可以同时发起无数个请求，并且响应可以同时返回。
.客户端和服务器可以把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。
于http2.0让所有数据流共用一个链接，可以更有效地使用TCP连接，让高带宽也能真正地服务于HTTP的性能提升。故“资源合并请求”的优化手段对于http2.0来说是没有效果的，只会增大无用的工作量而已。
        * ```请求优先级```
            * 由于所有的资源都是并行发送，可以对重要的文件进行先运输，加速页面的渲染。
        * ```服务器推送```在 HTTP2.0中，服务器推送是指在客户端请求之前发送数据的机制。如果一个请求是由你的主页发起的，服务器很可能响应主页内容、logo以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送有一个很大的优势：可以缓存！
        * 虽然 HTTP/2.0 协议并没声明一定要用 SSL，但是 Google Chrome 等浏览器强制要求使用 HTTP/2.0 必须要用上 SSL， 也就是说必须要。
* http2：
    * 为什么需要头部压缩？
        * 假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。
 
    * HTTP2.0多路复用有多好？
        * 之前就提到了，```http性能取决于带宽和延迟连个方面，现在带宽已经很好了，几乎不再是阻碍，真正的阻碍是延迟！```   HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。
* 发送http的一些方法   
    * GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT，这些是RFC2616标准（现行的HTTP/1.1）（HTTP的1.0版本中只有三种请求方法： GET, POST 和 HEAD方法）
    * GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端，问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制，用&（与运算符）隔开不同请求参数的键值对
    * POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，主要是提交请求/提交数据给服务器
    * HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。一般用于验证URI是否有效。
    * PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。
    举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。
    * DELETE：删除某一个资源
    * OPTIONS这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
    * TRACE回显服务器收到的请求，主要用于测试或诊断。
    * CONNECT的作用就是将服务器作为代理，让服务器代替用户去访问其他网页（说白了，就是翻墙），之后将数据返回给用户。
* http传递的是明文，信息不安全。所以有了https协议。其实就是在应用层和传输层之间增加一层安全层。https是用来身份认证和加密豹纹的协议。主要过程就是两方交换信息的放过中方协商好加密方式。客户端利用服务端的数字证书来判断其身份的安全性，两者最后都得到一个会话密钥来达到加密豹纹的目的。


>http 中如果想要使用缓存需要设置哪些字段
缓存分为强缓存和协商缓存。
* 强缓存主要是采用响应头中的``` Cache-Control 和 Expires ```两个字段进行控制的。
其中 Expires 是 HTTP1.0 中定义的，它指定了一个绝对的过期时期。而 Cache-Control 是 HTTP1.1 时出现的缓存控制字段。 由于 Expires 是 HTTP1.0 时代的产物，因此设计之初就存在着一些缺陷，如果本地时间和服务器时间相差太大，就会导致缓存错乱。
```这两个字段同时使用的时候 Cache-Control 的优先级会更高一点。```
* 协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（ Not Modified ），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。
     * 基于资源在服务器修改时间而验证缓存的过期机制
当客户端再次请求该资源的时候，会在其请求头上附带上 ```If-Modified-Since ```字段（值就是第一次获取请求资源时响应头中返回的 ```Last-Modified ```值）。如果修改时间未改变则表明资源未过期，命中缓存，服务器就直接返回 304 状态码，客户端直接使用本地的资源。否则，服务器重新发送响应资源，从而保证资源的有效性。
    * Etag 和 If-None-Match
        * 当客户端再次请求该资源的时候，会在其请求头上附带上 If-None-Match 字段（值就是第一次获取请求资源时响应头中返回的 Etag 值），其值与服务器端资源文件的验证码进行对比，如果匹配成功直接返回 304 状态码，从浏览器本地缓存取资源文件。如果不匹配，服务器会把新的验证码放在请求头的 Etag 字段中，并且以 200 状态码返回资源。
```需要注意的是当响应头中同时存在 Etag 和 Last-Modified 的时候，会先对 Etag 进行比对，随后才是 Last-Modified。```
- 当强缓存和协商缓存字段同时存在时会进行以下步骤来请求资源：
强缓存和协商缓存同时存在，如果强缓存还在有效期内则直接使用缓存；如果强缓存不在有效期，协商缓存生效。 即：```强缓存优先级 > 协商缓存优先级```
强缓存的 expires 和 cache-control 同时存在时， cache-control 会覆盖 expires 的效果， expires 无论有没有过期，都无效。 即： ```cache-control 优先级 > expires 优先级。```
协商缓存的 Etag 和 Last-Modified 同时存在时， Etag 会覆盖 Last-Modified的效果。 即： ```ETag 优先级 > Last-Modified 优先级```。

>IPV4 的地址有多少位？多少个字节？IPV6 的呢
IPv4的地址是32位，4个字节。IPv6的地址是64位。

？？？？？？？？？？？？？？？？？？？这里还能扩展。。

> 什么是子网掩码

> ARP 协议是什么

> OSI 模型了解吗？每一层你能想到哪些协议？

> 幂等？？？

> 会不会讲到各种校验



> 我觉得 这么说前面的话 会引出 REST 机制。。。。。

> 服务端如果告诉客户端可以使用缓存会返回什么状态码？服务端错误又是什么状态码？如果是服务端代理问题的又是什么状态码？

> GET 和 POST 请求有什么区别

>浏览器的 cookie 和服务端的 session 有什么区别

> 怎么实现多个网站之间共享登陆状态

> 交换机和路由器有什么区别

> 从广东一个站点访问上海的站点是怎么一个过程

> DNS 的工作原理了解吗

> 从浏览器输入 ‘qq.com’ 到看到这个页面整个过程是怎样的？追问：如果是本地的页面又是怎样的

> 浏览器的回流和重绘了解吗（介绍完我就顺便讲了怎么减少回流和重绘）


操作系统里面的进程和线程有什么区别？进程之间怎么通信？（坦然承认操作系统这块学得不好）
一个完整的数据库查找的语法是怎样的呢
什么是数据库的索引？什么时候需要用到索引
基本的算法还记得吗
快排是怎样实现的
什么是二叉树
怎么去算一个图的最短路径？比如 Dijkstra 算法，知道是怎么实现的吗
对称加密和非对称加密有哪些区别？又有哪些应用
常见的 web 攻击方式有哪些？他们具体是怎么攻击的
sql 注入怎么防范？XSS 怎么防范？CSRF 又怎么防范



#### 数据结构


#### 操作系统